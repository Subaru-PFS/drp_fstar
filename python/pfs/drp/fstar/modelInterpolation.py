import numpy as np
from . import parallel

import os
import pickle


class ModelInterpolation:
    """Read an RBF picke file model

    Parameters
    ----------
    model : `list` of `scipy.interpolate.Rbf`
        RBF model generated by `makeRBFInterpolationModel.py`.
        Each element (`Rbf`) of the list takes charge of the flux
        at one wavelength.
    wcs : `dict`
        FITS headers for converting the unit of wavelength to nm.
        Required keys are: ["CRPIX1", "CDELT1", "CRVAL1"].
    """

    def __init__(self, model, wcs):
        self.model = model

        start = wcs["CRVAL1"] + wcs["CDELT1"] * (1 - wcs["CRPIX1"])
        stop = wcs["CRVAL1"] + wcs["CDELT1"] * (len(model) - wcs["CRPIX1"])
        self.wavelength = np.linspace(start, stop, num=len(model), endpoint=True, dtype=float)

    @classmethod
    def fromFluxModelData(cls, path):
        """Read the RBF model in ``fluxmodeldata`` package.

        The RBF model must be generated in advance
        by `makeRBFInterpolationModel.py`.

        Parameters
        ----------
        path : `str`
            Path to ``fluxmodeldata`` package.

        Returns
        -------
        modelInterpolation : `ModelInterpolation`
            The model.
        """
        filePath = os.path.join(path, "interpolator.pickle")
        if not os.path.exists(filePath):
            raise RuntimeError(
                f"'{filePath}' not found. Run `makeRBFInterpolationModel.py` to generate it."
            )
        return cls.fromPickle(filePath)

    @classmethod
    def fromPickle(cls, path):
        """Read an RBF model from a picke file.

        Parameters
        ----------
        path : `str`
            File name of an RBF model
            generated by `makeRBFInterpolationModel.py`.

        Returns
        -------
        modelInterpolation : `ModelInterpolation`
            The model.
        """
        with open(path, "rb") as f:
            obj = pickle.load(f)
            return cls(obj["interpolationFunction"], obj["wcs"])

    def interpolate(self, teff, logg, metal, alpha, nProcs=1):
        """Generate an interpolated spectrum at a given parameter point.

        Parameters
        ----------
        teff : `float`
            Effective temepature in K for interpolation.
        logg : `float`
            Surface gravity in log(/(cm/s^2)) for interpolation.
        metal : `float`
            Metallicity [Fe/H] for interpolation.
        alpha : `float`
            Alpha element index [alpha/Fe] for interpolation.
        nProcs : `int`, optional
            A number of processes.

        Returns
        -------
        wavelength : `numpy.ndarray`
            Wavelength in nm.
        spectrum : `numpy.ndarray`
            Interpolation spectrum.
        """
        def doInterpolation(model):
            interpolationFunction = model
            interpolatedFlux = interpolationFunction(teff/1e3, logg, metal, alpha)
            return interpolatedFlux
        spectrum = parallel.parallel_map(doInterpolation, self.model, n_procs=nProcs)

        return np.copy(self.wavelength), np.asarray(spectrum)
